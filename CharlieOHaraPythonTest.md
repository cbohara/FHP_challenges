# Charlie O'Hara Python Test


## 0
### Why does the following program print `prime` for input `6`? 
```
x = 6
if x == 2 or 3 or 5 or 7:
	print('prime')
```
The if statement only checks if x equals 2.

### How should it be modified to print only when the value is one of the first four primes?
```
def first_four_primes(x):
	"""Check if number is one of the first four prime numbers."""
	if x in set([2, 4, 5, 7]):
		print('prime')
```


## 1

### Which of these is the most efficient, and why?
```
x in set([2, 3, 5, 7])
```

The set data type is ideal for membership checking because it uses a hash table as its underlying data structure.  On average looking for an item in a hash table is an O(1) operation.


## 2

### The following code should print `[5]`. Why doesn't it produce the expected output? 

Default values are only evaluated when the def statement they belong to are executed.  In the code below each call to init_data() uses the same data object.
```
def init_data(data=[]):
	"""Create a list containing the value 5."""
	data.append(5)
	return data
init_data()
print(init_data())
```

### How should it be fixed?
```
def init_data(data=None):
	"""Create a list containing the value 5."""
	if data is None:
		data = []
	data.append(5)
	return data
init_data()
print(init_data())
```


## 3

### What does the following code do?
```
if any([value % 2 for value in values]):
	print('done')
# or
if any(value % 2 for value in values):
	print('done')
```
The code will print 'done' if any element in an iterable is an even number.

### What is the difference between the two versions?
```
values = list(range(5))
if any([value % 2 for value in values]):
	print('done')
```
The first version uses a list comprehension.  The list generated by the list comprehension will contain True or False values - True if the original value is even and False if the original value is odd. Then any() will check if the list contains any True values. If the list is empty it will return False.

```
if any(value % 2 for value in values):
	print('done')
```
The second version leverages a generator expression.  Each value will be generated as any() iterates through the values iterable.  any() will stop iterating as soon as the first True value is found.


## 4

### What is the equivalent of the following code without using decorator syntax?
```
@bp.route('/info')
@login_required
def user_info():
	return jsonify(current_user)

# Without decorator syntax
bp.route('/info')(login_required(user_info))
```

### Does order matter when decorating a function multiple times?
Yes order matters.


## 5

### A list contains instances of the following class.  Write a function that will produce a sorted list ordered first by name descending, then id ascending.
```
class User:
	def __init__(self, id, name):
		self.id = id
		self.name = name
	def __repr__(self):
		return repr((self.id, self.name))
def sort_name_desc_id_asc(users):
	users.sort(key=lambda user: user.id)
	users.sort(key=lambda user: user.name, reverse=True)
	return users

users = [User(3, 'Charlie'), User(5, 'Charlie'), User(1, 'David'), User(4, 'Melanie'), User(2, 'Trey')]
sorted_users = sort_name_desc_id_asc(users)
```


## Bonus
### What does the following output?
```
x = [1, 2, 3, 4]
for x[-1] in x:
	print(x)
    
# Output
[1, 2, 3, 1]
[1, 2, 3, 2]
[1, 2, 3, 3]
[1, 2, 3, 3]
```
### Why? 
Slice assignment replaces x[-1] with the current iteration of the iterable.
